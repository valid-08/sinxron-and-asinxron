# Синхронный JavaScript
### Большая часть функциональности, которую мы рассматривали в предыдущих обучающих модулях, является синхронной — вы запускаете какой-то код, а результат возвращается, как только браузер может его вернуть. Давайте рассмотрим простой пример, как это работает:
![alt text](<snap 1-1.png>)
## В этом блоке кода команды выполняются одна за другой:
## 1. Получаем ссылку на элемент button, который уже есть в DOM.
## 2. Добавляем к кнопке обработчик события click так, что при нажатии на неё:
### Выводится сообщение alert().
### После закрытия сообщения создаём элемент p (абзац).
### Затем добавляем в абзац текст.
### В конце добавляем созданный абзац в тело документа.
### Пока выполняется каждая операция, ничего больше не может произойти — обработка (отображение) документа приостановлена. Так происходит, потому что JavaScript является однопоточным. В каждый момент времени может выполняться только одна команда, обрабатываемая в единственном — главном потоке. Все остальные действия блокируются до окончания выполнения текущей команды.
# Асинхронный JavaScript
# Введение в асинхронный JavaScript
### По причинам, упомянутым ранее (например, относящимся к блокировке), множество Web API особенностей теперь используют асинхронный код, особенно те,что имеют доступ к внешним устройствам или получают от них некоторые ресурсы, такие как получение файла из сети, запрос к базе данных и получение данных из базы, доступ к потоковому видео на веб-камере, просмотр дисплея на гарнитуре виртуальной реальности.
### Почему трудно работать, используя синхронный код? Давайте посмотрим на небольшой пример. Когда вы получаете картинку с сервера, вы не можете мгновенно вернуть результат. Это значит что следующий (псевдо) код не сработает:
![alt text](<Snap 2.png>)
### Это происходит потому что вы не знаете сколько времени займёт загрузка картинки, следовательно, когда вы начнёте выполнять вторую строку кода, сгенерируется ошибка (возможно, периодически, возможно, каждый раз), потому что response ещё не доступен. Вместо этого, ваш код должен дождаться возвращения response до того, как попытается выполнить дальнейшие инструкции.
### Есть два типа стиля асинхронного кода, с которыми вы столкнётесь в коде JavaScript, старый метод — колбэки (callbacks) и более новый — промисы (promises). В следующих разделах мы познакомимся с каждым из них.

![alt text](<Snap 3.png>)
### Первый параметр — тип обрабатываемого события, второй параметр — колбэк-функция, вызываемая при срабатывании события.
### При передаче колбэк-функции как аргумента в другую функцию, мы передаём только ссылку на функцию как аргумент, следовательно колбэк-функция не выполняется мгновенно. Она вызывается асинхронно внутри тела, содержащего функцию. Эта функция должна выполнять колбэк-функцию в нужный момент.
### Вы можете написать свою собственную функцию, содержащую колбэк-функцию
# Асинхронные колбэки
### Асинхронные обратные вызовы — это функции, переданные другой функции, которая начинает выполнять код в фоновом режиме. Обычно, когда код в фоновом режиме завершается, асинхронная функция обратного вызова вызывается как способ уведомления и передачи данных в функцию обратного вызова о том, что фоновая задача завершена
# new Promise
### В JavaScript обещание — это хороший способ обработки асинхронных операций. Оно используется для выяснения, успешно ли завершена асинхронная операция или нет.
### Конструктор Promise() принимает функцию в качестве аргумента. Функция также принимает две функции resolve() и reject(). Если обещание возвращается успешно, вызывается функция resolve(). А если возникает ошибка, вызывается функция reject().
![alt text](image.png)